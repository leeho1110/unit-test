# unit-test
블라디미르 코리코프의 서적 '단위 테스트'를 읽고 정리한 레포지토리입니다.

---

### 서평

팀 내 테스트 코드 작성 문화의 도입을 위해 준비하던 과정에서 읽게 됐습니다. 단위 테스트가 어떤 것인지 명확하게 설명하고 어떤 장점들을 얻을 수 있으며 만약 작성하게 된다면 어떤 점들을 주의해야 하는지 학습하기 위해 선택했습니다. 

- ***Q. 단위 테스트란 무엇일까요?***

    **단일 동작 단위를 검증**하고 빠르게 수행되며 다른 테스트와 별도로 처리하는 자동화된 테스트입니다.
    
    - ***Q. 다른 테스트와 별도로 처리한다는 것이 어떤 의미인가요?***
    
        다른 단위 테스트들과 공유 상태를 일으키는 의존성을 제거한 상태를 의미합니다. 일반적으로 정적 가변 필드, 파일 시스템, 데이터베이스와 같은 프로세스 외부 의존성이 대표적인 예시입니다.
        
    - ***Q. 단위 테스트의 안티 패턴엔 어떤게 있을까요?***
    
        첫 번째로는 private 메서드를 검증하는 행위입니다. private 메서드는 퍼블릭 인터페이스에 노출되지 않는 세부 구현에 해당되는 메서드입니다. 이를 테스트하는 것은 테스트가 세부 구현과 결합되어 리팩토링 내성을 잃어버리는 것을 의미합니다.
        
        두 번째로는 테스트 내부에서 도메인 모델 알고리즘을 노출하지 않는 것입니다. 테스트에서 예상되는 결과값을 하드 코딩하고 매개변수화하여 검증해야 합니다.
        

- ***Q. 단위 테스트는 왜 작성해야 할까요? 궁극적인 목표가 무엇인지?***

    **회귀(버그) 방지를 통한 지속 가능한 성장을 가능케하는 것**이 단위 테스트의 목적입니다. 테스트를 통해 얻을 수 있다고 알려진 더 나은 설계, 개발자의 생산성 증대는 사실 부수 효과입니다. 단위 테스트가 없다면 시스템이 복잡해지고 여러 버그들을 내포한 소프트웨어로 변질됩니다. 이는 소프트웨어의 신뢰도의 추락을 의미하고 결국은 도미노 효과처럼 소프트웨어 전체가 무너집니다. 테스트는 이런 문제를 방지하는 안전망 역할입니다.
    
- ***Q. 어떤 테스트가 좋은 테스트일까요?***
    
    회귀(버그)가 존재하지 않도록 방지하며, 리팩터링에 내성을 갖추고, 빠른 속도로 처리되는 테스트가 좋은 테스트입니다. 이 3가지 요소를 모두 가질 순 없습니다. 따라서 회귀 방지와 빠른 피드백 사이에서 트레이드 오프를 결정하고 **리팩터링 내성을 최대화**시키는 방향이 좋습니다. 이를 위해선 테스트가 검증하려는 대상이 구현 세부 사항 대신 **최종 결과**이어야  합니다.
        
    테스트의 성격은 시스템의 내부 구조를 몰라도 시스템의 기능을 검사하는 블랙박스 테스트와 애플리케이션의 내부 작업을 검증하는 화이트박스 테스트 방식로 나눠지는데요. 화이트박스 테스트는 허위 경보(최종 결과가 일치하지만 세부 구현이 변경되면 테스트가 깨짐)가 많이 생기며, 좋은 테스트는 리팩터링 내성이 최우선되어야 하기 때문에 블랙박스 테스트를 디폴트로 가져가야 합니다.
        
    - ***Q. 모든 코드에 테스트가 필요한가요?***
    
        꼭 그렇진 않습니다. 따라서 복잡한 비즈니스 로직을 검증하는 코드와 아주 단순한 getter,setter를 검증하는 코드의 중요도는 다릅니다. 단순한 코드를 테스트하는 것은 시간 낭비, 코드 낭비일 뿐입니다. 단위 테스트의 목적은 소프트웨어의 지속 가능한 성장이었습니다. 이에 도움이 되는 테스트를 작성하세요.
        
- ***Q. 테스트 대역이란 무엇인가요?***

    소프트웨어를 운용할 때 필요한 **비운영용 가짜 의존성**을 의미합니다. 제라드 메스자로서에 의하면 더미(dummy), 스텁(stub), 스파이(spy), 목(mock), 페이크(fake)로 나눠지지만 상위 레벨에서는 목(목, 스파이)과 스텁(스텁, 더미, 페이크)으로 나눌 수 있습니다.
        
    - ***Q. 목(Mock)과 스텁(Stub)은 어떻게 다른가요?***

        둘다 SUT와 협력자 사이의 상호작용을 검사하는 테스트 대역입니다. 다만 목적에 따라 둘로 나눠집니다. 목은 **외부로 나가는 상호 작용(상태를 변경하기 위한 의존성을 호출)을 모방하고 검사** 할 때 필요합니다. 반면 스텁은 **내부로 들어오는 상호 작용(입력 데이터를 얻기 위한 의존성을 호출)을 모방**할 때 필요합니다. 여기서 스텁으로 상호 작용을 검증해서는 안됩니다. 이는 내부 구현이 테스트와 결합되는 취약점을 야기하는 안티 패턴입니다.
    
    - ***Q. 모든 의존성을 목으로 대체해야 할까요?***
    
        아니요. 애플리케이션을 통해서만 접근할 수 있는 통제 가능한 의존성(관리 의존성)이라면 애플리케이션 구현 세부 사항과 같으므로 모킹하지 않아도 됩니다. 만약 공유 의존성이 프로세스 외부에 있다면 테스트에 존재하는 의존성을 격리하기 어려워진다. 따라서 이 경우 의존성을 목, 스텁으로 대체하면 됩니다.
        
        의존성에는 테스트 간 공유하는 의존성(프로덕션 코드 X)인 공유 의존성, 데이터베이스, 메시지 버스, SMTP 서비스와 같은 프로세스 외부 의존성, 공유하지 않는 모든 의존성인 비공개 의존성이 존재합니다.    
        
- ***Q. 통합 테스트란 무엇일까요? ***

    도메인 모델과 프로세스 외부 의존성의 연결을 검증하는 테스트를 통합 테스트라고 합니다. 통합 테스트는 가장 긴 주요 핵심 흐름과 단위 테스트로는 수행 불가능한 모든 예외 상황을 다룹니다.
        
